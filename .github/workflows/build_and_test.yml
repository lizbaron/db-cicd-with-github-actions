# This workflow creates two SQL Server instances (2017, 2019) on kubernetes in separate namespaces using saved container images in an ACR. 
# Builds and tests a database project (in this case tSQLt) 
# 
# AZURE: Before this workflow will run successfully you must do the following
# 1. Run the github action workflow, "cicd_environment_setup.yml"

name: CI Build and Test

# Controls when the action will run. 
on:
  workflow_dispatch: 

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build-tSQLt:
    name: build tSQLt
    if: ${{ false }}

    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20

    env:
      PFX_PATH: ${{ github.workspace }}\tSQLt\Build\tSQLtOfficialSigningKey.pfx
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}
      ARTIFACT_DIR: ${{ github.workspace }}\artifacts
      
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it. But this is misleading, because this variable is only really helpful as ${{ github.workspace }}
      - name: Checkout self
        uses: actions/checkout@v2
        with:
          path: cicd

      - name: Checkout tSQLt
        uses: actions/checkout@v2
        with:
          repository: tSQLt-org/tSQLt
          path: tSQLt
          token: ${{ secrets.my_pat }}

      # documentation: 
      - name: create and install unofficial pfx file for signing dlls
        shell: pwsh
        run: |
          $cert = New-SelfSignedCertificate -FriendlyName "tSQLt_testKey" -Type CodeSigningCert -Subject "CN=localhost" -KeyAlgorithm RSA -HashAlgorithm SHA1 -KeyLength 2048 -SmimeCapabilities -CertStoreLocation "cert:/LocalMachine" -Provider "Microsoft Strong Cryptographic Provider"
          $pwd = ConvertTo-SecureString -String "$env:PFX_PASSWORD" -Force -AsPlainText
          $pfxFile = Export-PfxCertificate -cert ("Cert:\LocalMachine\My\" + $cert.thumbprint) -FilePath $env:PFX_PATH -Password $pwd
          &"${{ github.workspace }}\tSQLt\Build\SnInstallPfx" $env:PFX_PATH "$env:PFX_PASSWORD" tSQLt_OfficialSigningKey

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v1.0.2

      - name: build tsqltCLR
        shell: pwsh
        run: |
          cd ${{ github.workspace }}\tSQLt\tSQLtCLR
          msbuild .\tSQLtCLR.sln -m -p:Configuration=CruiseControl

      - name: copy files to artifact staging and compress to tSQLtCLR.zip
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          New-Item -ItemType Directory -Path ${{ github.workspace }}\tSQLt\Build\output
          Get-Item -Path ${{ github.workspace }}\tSQLt\tSQLtCLR\*\bin\*\* -Filter *.dll | Copy-Item -Destination $env:ARTIFACT_DIR\tSQLtCLR -Container:$false
          $compress = @{
            Path = "$env:ARTIFACT_DIR\tSQLtCLR\*.dll"
            CompressionLevel = "Fastest"
            DestinationPath = "${{ github.workspace }}\tSQLt\Build\output\tSQLtCLR.zip"
            }
          Compress-Archive @compress
 
      - name: ant -debug Build/tSQLt.build.xml
        run: ant -noinput -debug -buildfile ${{ github.workspace }}\tSQLt\Build\tSQLt.build.xml all

      - name: copy tSQLt artifacts to ${{ env.artifact_dir }}
        shell: pwsh
        run: |
          # @SM --> TODO
          Remove-Item .\artifacts\ -Recurse
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          $basePath = "${{ github.workspace }}\tSQLt\Build\output\";
          $artifactFiles = (@("Version.txt","tSQLt.zip","tSQLt.tests.zip","tSQLtSnippets(SQLPrompt).zip")| ForEach-Object { $basePath + $_ });
          $artifactFiles | Copy-Item -Verbose -Destination $env:ARTIFACT_DIR;

      - name: Archive production artifact
        uses: actions/upload-artifact@v2
        with:
          if-no-files-found: error
          name: tSQLtAndTests
          path: |
            ${{ env.artifact_dir }}\

  test:
    needs: build-tSQLt
    name: test build artifacts
    # TODO: Remove this always nonsense
    if: ${{ always() }}

    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20
    strategy: 
      matrix:
        mssqlversion: [mssql2017, mssql2019]

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:

      - name: Checkout self
        uses: actions/checkout@v2
        with:
          path: cicd

      - name: Checkout tSQLt
        uses: actions/checkout@v2
        with:
          repository: tSQLt-org/tSQLt
          path: tSQLt
          token: ${{ secrets.my_pat }}

      - name: print matrix mssqlversion
        shell: pwsh
        run: |
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          Write-Host "";
          Write-Host ("Matrix mssqlversion: {0}" -f "${{ matrix.mssqlversion }}"); 
          Write-Host ("GitHub Run Id: {0}" -f "${{ github.run_id }}"); 
          Write-Host ("GitHub Run Number: {0}" -f "${{ github.run_number }}"); 
          Write-Host ("GitHub Action: {0}" -f "${{ github.action }}"); 
          Write-Host ("GitHub Repository: {0}" -f "${{ github.repository }}"); 
          Write-Host ("GitHub SHA: {0}" -f "${{ github.sha }}"); 
          Write-Host "";
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";

      # documentation: https://github.com/azure/login#configure-azure-credentials
      # next steps is to set up a service principal in azure which has permission to set up its own resource group and resources within that resource group, but not mess with those that it has not set up.
      - name: login via az module
        uses: azure/login@v1
        with:
          creds: ${{secrets.AZ_SP_CREDENTIALS}}
          enable-AzPSSession: true 

      # documentation: https://github.com/Azure/get-keyvault-secrets
      - name: get azure secrets
        uses: Azure/get-keyvault-secrets@v1.0
        with:
          keyvault: "sm-52F71DC003"
          secrets: 'azResourceGroupName, aksClusterName'  # comma separated list of secret keys that need to be fetched from the Key Vault 
        id: get-azure-secrets

      # Set the target AKS cluster.
      - name: set aks context
        uses: Azure/aks-set-context@v1
        with:
          creds: '${{ secrets.AZ_SP_CREDENTIALS }}'
          cluster-name: ${{ steps.get-azure-secrets.outputs.aksClusterName }}
          resource-group: ${{ steps.get-azure-secrets.outputs.azResourceGroupName }}

      - name: create the aks namespace for this job
        shell: pwsh
        run: |
          kubectl get namespace
          kubectl create namespace ns-${{ github.run_id }}-${{ github.run_number }}-${{ matrix.mssqlversion }} # must be no longer than 63 chars https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names

# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - #


      # # documentation: https://github.com/Azure/PowerShell
      # - name: run azure powershell script
      #   uses: azure/powershell@v1
      #   with:
      #     azPSVersion: 'latest'
      #     errorActionPreference: 'continue'
      #     inlineScript: |


      
      # # documentation: https://github.com/Azure/k8s-create-secret
      # - name: Set imagePullSecret 
      #   uses: azure/k8s-create-secret@v1
      #   with:
      #     namespace: 'myapp'
      #     container-registry-url: 'containerregistry.contoso.com'
      #     container-registry-username: ${{ secrets.REGISTRY_USERNAME }}
      #     container-registry-password: ${{ secrets.REGISTRY_PASSWORD }}
      #     secret-name: 'contoso-cr'
      #   id: create-secret

      # - name: deploy to aks
      #   uses: Azure/k8s-deploy@v1.3
      #   with:
      #     namespace: 'myapp'
      #     manifests: |
      #         deployment.yaml
      #         service.yaml
      #     images: 'contoso.azurecr.io/myapp:${{ event.run_id }}'
      #     imagepullsecrets: |
      #       image-pull-secret1
      #       image-pull-secret2
      #     kubectl-version: 'latest'


# >>>>>>>>>>>> START HERE <<<<<<<<<<<<<<
      
    # - task: PowerShell@2
    #   name: GetVariablesInPlace
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       Write-Host '$(CreateVMAndMore.SerializedDTLDetails)';
    #       $DTLDetails = (ConvertFrom-JSON '$(CreateVMAndMore.SerializedDTLDetails)');
    #       #-----------------------------------------------------------------------#
    #       # IMPORTANT (and, you've got to be kidding me):                         #
    #       # The space below is absolutely required to make the ANT Task work.     #
    #       #--------------------------------------|--------------------------------#
    #       $FQDNAndPort = $DTLDetails.SQLVmFQDN+", "+$DTLDetails.SQLVmPort;
    #       #--------------------------------------|--------------------------------#
    #       #-----------------------------------------------------------------------#
    #       $SQLVersion = $DTLDetails.SQLVersion;
    #       Write-Host "##vso[task.setvariable variable=FQDNAndPort]$FQDNAndPort"
    #       Write-Host "##vso[task.setvariable variable=SQLVersion]$SQLVersion"
    # - task: PowerShell@2
    #   name: PrintSQLVersionInfo
    #   env:
    #     USER_NAME: $(tSQLt-UserForCIEnvironment-UserName)
    #     PASSWORD: $(tSQLt-UserForCIEnvironment-Password)
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       $DS = Invoke-Sqlcmd -Query "SELECT SUSER_NAME() U,SYSDATETIME() T,@@VERSION V;" -ServerInstance "$(FQDNAndPort)" -Username "$env:USER_NAME" -Password "$env:PASSWORD" -As DataSet
    #       $DS.Tables[0].Rows | %{ echo "{ $($_['U']), $($_['T']), $($_['V']) }" }    
    
    # - task: Ant@1
    #   name: Run_tSQLt_validatebuild_xml
    #   inputs:
    #     buildFile: '../tSQLt/Build/tSQLt.validatebuild.xml'
    #     options: '-Ddb.version="$(SQLVersion)" -Ddb.server="$(FQDNAndPort)" -Ddb.name=tSQLt_dev -Ddb.login="-U $(tSQLt-UserForCIEnvironment-UserName) -P $(tSQLt-UserForCIEnvironment-Password)" -Dsqlcmd.path="$(SQLCMDPath)"'
    #     targets: 'all'
    #     publishJUnitResults: true
    #     testResultsFiles: '../**/?(Example)TestResults*.xml'
    #     testRunTitle: '$(SQLVersionEdition)'
    #     javaHomeOption: 'JDKVersion'
        
    # - task: PowerShell@2
    #   name: CreateTestResultArtifact
    #   inputs:
    #     targetType: 'inline'
    #     failOnStderr: true
    #     script: |
    #       "---------------------------------------------------"
    #       $BasePath = "$(Build.SourcesDirectory)\..";
    #       $BasePath;
    #       "==================================================="
    #       $ArtifactPath = ($BasePath+"\tSQLt\Build\output\TestResults\");
    #       $ArtifactPath;
    #       "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    #       New-Item -Path $ArtifactPath  -ItemType directory -Force
    #       (Get-ChildItem $BasePath -recurse);
    #       "== == == == == == == == == == == == == == == == == "
    #       (Get-ChildItem $BasePath -recurse)|Out-File  -FilePath $ArtifactPath+"dir.txt"
    #       (Get-ChildItem $BasePath -recurse -include "*TestResults*.xml").FullName; 
    #       "==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-"
    #       (Get-ChildItem $BasePath -recurse -include "*TestResults*.xml").FullName|Copy-Item -Destination $ArtifactPath -recurse -PassThru
    #       Set-Content -Path ($ArtifactPath+"CommitId.txt") -Value "$(Build.SourceVersion)"
    #       "=== === === === === === === === === === === === ==="
    # - task: PublishPipelineArtifact@1
    #   name: PublishTestResultArtifact
    #   inputs:
    #     targetPath: '$(Build.SourcesDirectory)/../tSQLt/Build/output/TestResults'
    #     artifact: 'TestResults_$(SQLVersionEdition)'
    #     publishLocation: 'pipeline'
