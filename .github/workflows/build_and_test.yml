# This workflow creates two SQL Server instances (2017, 2019) on kubernetes in separate namespaces using saved container images in an ACR. 
# Builds and tests a database project (in this case tSQLt) 
# 
# AZURE: Before this workflow will run successfully you must do the following
# 1. Run the github action workflow, "cicd_environment_setup.yml"

name: CI Build and Test

# Controls when the action will run. 
on:
  workflow_dispatch: 

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build-tSQLt:
    name: build tSQLt
    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20

    env:
      PFX_PATH: ${{ github.workspace }}\tSQLt\Build\tSQLtOfficialSigningKey.pfx
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}
      ARTIFACT_DIR: ${{ github.workspace }}\artifacts
      
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
        with:
          path: cicd

      - name: Checkout tSQLt
        uses: actions/checkout@v2
        with:
          repository: tSQLt-org/tSQLt
          path: tSQLt
          token: ${{ secrets.my_pat }}

      # documentation: 
      - name: create and install unofficial pfx file for signing dlls
        shell: pwsh
        run: |
          $cert = New-SelfSignedCertificate -FriendlyName "tSQLt_testKey" -Type CodeSigningCert -Subject "CN=localhost" -HashAlgorithm SHA1 -KeyLength 2048 -SmimeCapabilities -CertStoreLocation "cert:/LocalMachine" -Provider "Microsoft Strong Cryptographic Provider"
          $pwd = ConvertTo-SecureString -String "$env:PFX_PASSWORD" -Force -AsPlainText
          $pfxFile = Export-PfxCertificate -cert ("Cert:\LocalMachine\My\" + $cert.thumbprint) -FilePath $env:PFX_PATH -Password $pwd
          &"$(Build.SourcesDirectory)/Build/SnInstallPfx" $env:PFX_PATH "$env:PFX_PASSWORD" tSQLt_OfficialSigningKey

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v1.0.2

      - name: build tsqltCLR
        shell: pwsh
        run: |
          cd ${{ github.workspace }}\tSQLtCLR
          msbuild .\tSQLtCLR.sln -m -p:Configuration=CruiseControl

      - name: copy files to artifact staging and compress to tSQLtCLR.zip
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          Get-Item -Path ${{ github.workspace }}\tSQLt\tSQLtCLR\*\bin\*\* -Filter *.dll | Copy-Item -Destination $env:ARTIFACT_DIR\tSQLtCLR -Container:$false
          Copy-Item -Path . -Destination $env:ARTIFACT_DIR\tSQLtCLR -Filter */bin/*/*.dll -Recurse -Container:$false
          $compress = @{
            Path = "$env:ARTIFACT_DIR\tSQLtCLR\*.dll"
            CompressionLevel = "Fastest"
            DestinationPath = "$env:ARTIFACT_DIR\tSQLtCLR.zip"
            }
          Compress-Archive @compress
 
      - name: ant -debug Build/tSQLt.build.xml
        run: ant -noinput -debug -buildfile Build/tSQLt.build.xml all

      - name: copy files to artifact staging and compress to tSQLtCLR.zip
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          Get-Item -Path ${{ github.workspace }}\tSQLt\tSQLtCLR\*\bin\*\* -Filter *.dll | Copy-Item -Destination $env:ARTIFACT_DIR\tSQLtCLR -Container:$false
          Copy-Item -Path . -Destination $env:ARTIFACT_DIR\tSQLtCLR -Filter */bin/*/*.dll -Recurse -Container:$false
          $compress = @{
            Path = "$env:ARTIFACT_DIR\tSQLtCLR\*.dll"
            CompressionLevel = "Fastest"
            DestinationPath = "$env:ARTIFACT_DIR\tSQLtCLR.zip"
            }
          Compress-Archive @compress

      - name: create tSQLt artifact staging and compress to tSQLtCLR.zip
        shell: pwsh
        run: |
          $env:ARTIFACT_DIR
          $basePath = "${{ github.workspace }}\tSQLt\Build\output";
          $artifactFiles = (@("Version.txt","tSQLt.zip","tSQLt.tests.zip","tSQLtSnippets(SQLPrompt).zip")| ForEach-Object { $basePath + $_ });
          $artifactFiles | Copy-Item -Verbose -Destination $env:ARTIFACT_DIR;
          $filesToCompress = ((Get-ChildItem -Path $env:ARTIFACT_DIR -File).FullName | ForEach-Object {"`""+$_+"`""}) -join ", "
          $compress = @{
            Path = $filesToCompress
            CompressionLevel = "Fastest"
            DestinationPath = "$env:ARTIFACT_DIR\tSQLtAndTests.zip"
            }
          Compress-Archive @compress

      - name: Archive production artifact
        uses: actions/upload-artifact@v2
        with:
          name: tSQLtAndTests
          path: |
              $env:ARTIFACT_DIR\tSQLtAndTests.zip

  test:
    needs: build-tSQLt
    name: test build artifacts
    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # documentation: https://github.com/azure/login#configure-azure-credentials
      # next steps is to set up a service principal in azure which has permission to set up its own resource group and resources within that resource group, but not mess with those that it has not set up.
      - name: login via az module
        uses: azure/login@v1
        with:
          creds: ${{secrets.az_sp_credentials}}
          enable-azpssession: true 

      
    
