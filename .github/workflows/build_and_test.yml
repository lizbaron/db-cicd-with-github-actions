# This workflow creates two SQL Server instances (2017, 2019) on kubernetes in separate namespaces using saved container images in an ACR. 
# Builds and tests a database project (in this case tSQLt) 
# 
# AZURE: Before this workflow will run successfully you must do the following
# 1. Run the github action workflow, "cicd_environment_setup.yml"

name: CI Build and Test

# Controls when the action will run. 
on:
  workflow_dispatch: 

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build-tSQLt:
    name: build tSQLt
#    if: ${{ false }}

    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20

    env:
      PFX_PATH: ${{ github.workspace }}\tSQLt\Build\tSQLtOfficialSigningKey.pfx
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}
      ARTIFACT_DIR: ${{ github.workspace }}\artifacts
      
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it. But this is misleading, because this variable is only really helpful as ${{ github.workspace }}
      - name: Checkout self
        uses: actions/checkout@v2
        with:
          path: cicd

      - name: Checkout tSQLt
        uses: actions/checkout@v2
        with:
          repository: tSQLt-org/tSQLt
          path: tSQLt
          token: ${{ secrets.my_pat }}

      # documentation: 
      - name: create and install unofficial pfx file for signing dlls
        shell: pwsh
        run: |
          $cert = New-SelfSignedCertificate -FriendlyName "tSQLt_testKey" -Type CodeSigningCert -Subject "CN=localhost" -KeyAlgorithm RSA -HashAlgorithm SHA1 -KeyLength 2048 -SmimeCapabilities -CertStoreLocation "cert:/LocalMachine" -Provider "Microsoft Strong Cryptographic Provider"
          $pwd = ConvertTo-SecureString -String "$env:PFX_PASSWORD" -Force -AsPlainText
          $pfxFile = Export-PfxCertificate -cert ("Cert:\LocalMachine\My\" + $cert.thumbprint) -FilePath $env:PFX_PATH -Password $pwd
          &"${{ github.workspace }}\tSQLt\Build\SnInstallPfx" $env:PFX_PATH "$env:PFX_PASSWORD" tSQLt_OfficialSigningKey

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v1.0.2

      - name: build tsqltCLR
        shell: pwsh
        run: |
          cd ${{ github.workspace }}\tSQLt\tSQLtCLR
          msbuild .\tSQLtCLR.sln -m -p:Configuration=CruiseControl

      - name: copy files to artifact staging and compress to tSQLtCLR.zip
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          New-Item -ItemType Directory -Path ${{ github.workspace }}\tSQLt\Build\output
          Get-Item -Path ${{ github.workspace }}\tSQLt\tSQLtCLR\*\bin\*\* -Filter *.dll | Copy-Item -Destination $env:ARTIFACT_DIR\tSQLtCLR -Container:$false
          $compress = @{
            Path = "$env:ARTIFACT_DIR\tSQLtCLR\*.dll"
            CompressionLevel = "Fastest"
            DestinationPath = "${{ github.workspace }}\tSQLt\Build\output\tSQLtCLR.zip"
            }
          Compress-Archive @compress
 
      - name: ant -debug Build/tSQLt.build.xml
        run: ant -noinput -debug -buildfile ${{ github.workspace }}\tSQLt\Build\tSQLt.build.xml all

      - name: copy tSQLt artifacts to ${{ env.artifact_dir }}
        shell: pwsh
        run: |
          # @SM --> TODO
          Remove-Item .\artifacts\ -Recurse
          New-Item -ItemType Directory -Path $env:ARTIFACT_DIR\tSQLtCLR
          $basePath = "${{ github.workspace }}\tSQLt\Build\output\";
          $artifactFiles = (@("Version.txt","tSQLt.zip","tSQLt.tests.zip","tSQLtSnippets(SQLPrompt).zip")| ForEach-Object { $basePath + $_ });
          $artifactFiles | Copy-Item -Verbose -Destination $env:ARTIFACT_DIR;

      - name: Archive production artifact
        uses: actions/upload-artifact@v2
        with:
          if-no-files-found: error
          name: tSQLtAndTests
          path: |
            ${{ env.artifact_dir }}\

  test:
    needs: build-tSQLt
    name: test build artifacts
    # TODO: Remove this always nonsense
    if: ${{ always() }}

    # More types found here, https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners
    # Note: [https://kubernetes.io/docs/tasks/tools/install-kubectl/#before-you-begin]
    #     You must use a kubectl version that is within one minor version difference of your cluster. For example, a v1.2 client should work with v1.1, v1.2, and v1.3 master. Using the latest version of kubectl helps avoid unforeseen issues.
    runs-on: windows-latest # Kubectl 1.20
    env:
      SQL_PORT_MIN: ${{ secrets.SQL_PORT_MIN }}
      SQL_PORT_MAX: ${{ secrets.SQL_PORT_MAX }}
      SA_PASSWORD: ${{ secrets.SA_PASSWORD }}

    strategy: 
      matrix:
        mssqlversion: [mssql2017]

      # MDP: Fail-Fast-Behavior
      #    : https://github.community/t/why-a-matrix-step-will-be-canceled-if-another-one-failed/16184
      fail-fast: false

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:

      - name: Checkout self
        uses: actions/checkout@v2
        with:
          path: cicd

      - name: Checkout tSQLt
        uses: actions/checkout@v2
        with:
          repository: tSQLt-org/tSQLt
          path: tSQLt
          token: ${{ secrets.my_pat }}

      - name: print matrix variables
        shell: pwsh
        run: |
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          Write-Host "";
          # TODO: ensure that ports do not collide between namespaces
          $sqlPort = Get-Random -Minimum $env:SQL_PORT_MIN -Maximum $env:SQL_PORT_MAX
          Write-Host ("sqlPort value: {0}" -f $sqlPort); 
          Write-Host ("Matrix mssqlversion: {0}" -f "${{ matrix.mssqlversion }}"); 
          Write-Host ("GitHub Run Id: {0}" -f "${{ github.run_id }}"); 
          Write-Host ("GitHub Run Number: {0}" -f "${{ github.run_number }}"); 
          Write-Host ("GitHub Action: {0}" -f "${{ github.action }}"); 
          Write-Host ("GitHub Repository: {0}" -f "${{ github.repository }}"); 
          Write-Host ("GitHub SHA: {0}" -f "${{ github.sha }}"); 
          Write-Host ("GitHub Runner Tracking Id: {0}" -f "$env:RUNNER_TRACKING_ID"); # undocumented
          Write-Host "";
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          # k8s namespaces must be no longer than 63 chars https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names
          $sqlcmdPath = (Get-Command sqlcmd).Path;
          echo "namespace=ns-${{ github.run_id }}-${{ github.run_number }}-${{ matrix.mssqlversion }}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append 
          echo "sqlPort=$sqlPort" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "sqlcmdPath=$sqlcmdPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          
      - name: download tSQLtAndTests artifact
        uses: actions/download-artifact@v2
        with:
          name: tSQLtAndTests
          path: ${{ github.workspace }}\tSQLt\Build_Artifact

      - name: print echo namespace env variables
        shell: pwsh
        run: |
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          Write-Host "";
          Write-Host "Dir ${{ github.workspace }}\tSQLt\Build_Artifact -- ";
          Get-ChildItem -Path ${{ github.workspace }}\tSQLt\Build_Artifact
          Write-Host "";
          Write-Host ("namespace value: {0}" -f $env:namespace); 
          Write-Host ("sqlPort value: {0}" -f $env:sqlPort); 
          Write-Host "";
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          
      # documentation: https://github.com/azure/login#configure-azure-credentials
      # next steps is to set up a service principal in azure which has permission to set up its own resource group and resources within that resource group, but not mess with those that it has not set up.
      - name: login via az module
        uses: azure/login@v1
        with:
          creds: ${{secrets.AZ_SP_CREDENTIALS}}
          enable-AzPSSession: true 

      # documentation: https://github.com/Azure/get-keyvault-secrets
      - name: get azure secrets
      # TODO: Consider deleting this task and getting these manually and setting them as secrets.
        uses: Azure/get-keyvault-secrets@v1.0
        env:
          ACTIONS_ALLOW_UNSECURE_COMMANDS: 'true' # Note that this task can be replaced with a similar pattern as setting the namespace to the env variables (above), but is also not secure.
        with:
          keyvault: "sm-52F71DC003"
          secrets: 'azResourceGroupName, aksClusterName'  # comma separated list of secret keys that need to be fetched from the Key Vault 
        id: get-azure-secrets

      # Set the target AKS cluster.
      - name: set aks context
        uses: Azure/aks-set-context@v1
        with:
          creds: '${{ secrets.AZ_SP_CREDENTIALS }}'
          cluster-name: ${{ steps.get-azure-secrets.outputs.aksClusterName }}
          resource-group: ${{ steps.get-azure-secrets.outputs.azResourceGroupName }}

      - name: create the aks namespace for this job
        shell: pwsh
        run: |
          # display the values of all the environment variables
          # MDP: secrets seem pretty secret
          Get-ChildItem Env: | Sort Name

          # create the namespace
          kubectl config current-context
          kubectl get namespace
          kubectl create namespace $env:namespace 
          kubectl config set-context --current --namespace=$env:namespace

      - name: apply deployments to aks
        shell: pwsh
        run: |

          kubectl get namespace

          kubectl create secret generic mssql-secret --from-literal=sa_password="$env:SA_PASSWORD"
          # @SM --> TODO: change sa_password from default

          # @SM --> TODO: template "stuff"
          kubectl apply -f ${{ github.workspace }}\cicd\aks\${{ matrix.mssqlversion }}.deployment.yml
          kubectl expose deployment ${{ matrix.mssqlversion }}-deployment --type=LoadBalancer --name=${{ matrix.mssqlversion }}-service --port=$env:sqlPort --target-port=1433
          kubectl wait pod --for=condition=Ready --all --timeout 600s # Experimental (https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#wait)
          kubectl get services ${{ matrix.mssqlversion }}-service -o json
          $ipAddress = kubectl get services ${{ matrix.mssqlversion }}-service -o jsonpath="{.status.loadBalancer.ingress[0].ip}"

          # add environment variables
          #---------------------------------------------------------------------------------------------------#
          # IMPORTANT (and, you've got to be kidding me):                                                     #
          # The space between the comma and the sqlPort is absolutely required to make the ANT Task work.     #
          #---------------------------------------------------------------------------------------------------#
          $fqdnAndPort = $ipAddress + ", " + $env:sqlPort;
          #-----------------------------^---------------------------------------------------------------------#
          #-----------------------------^---------------------------------------------------------------------#
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          Write-Host "";
          Write-Host ("fqdnAndPort value: {0}" -f $fqdnAndPort); 
          Write-Host "";
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";

          echo "ipAddress=$ipAddress" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "fqdnAndPort=$fqdnAndPort" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: check sql server instance
        shell: pwsh
        run: |
          kubectl exec service/${{ matrix.mssqlversion }}-service -- powershell.exe -c 'Get-Service MSSQL*'

      - name: get directory listing
        shell: pwsh
        run: |
          dir -S

      - name: check sql server instance
        shell: pwsh
        run: |
          kubectl exec service/${{ matrix.mssqlversion }}-service -- powershell.exe -c 'Get-Service MSSQL*'

      - name: print sql version info
        shell: pwsh
        run: |
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
          Write-Host "";
          # @SM --> TODO: Fix the password issue.
          Write-Host Invoke-Sqlcmd -Query "SELECT SUSER_NAME() U,SYSDATETIME() T,@@VERSION V;" -ServerInstance "$env:fqdnAndPort" -Username "sa" -Password "$env:SA_PASSWORD" -As DataSet
          $DS = Invoke-Sqlcmd -Query "SELECT SUSER_NAME() U,SYSDATETIME() T,@@VERSION V;" -ServerInstance "$env:fqdnAndPort" -Username "sa" -Password "$env:SA_PASSWORD" -As DataSet

          $DS.Tables[0].Rows | %{ echo "{ $($_['U']), $($_['T']), $($_['V']) }" }    
          Write-Host "";
          Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";


      # @SM --> TODO: Fix the password issue
      # @SM --> TODO: jUnit results
      - name: ant -debug Build/tSQLt.validatebuild.xml
        working-directory: ${{ github.workspace }}\tSQLt\Build
        run: ant -noinput -debug -buildfile tSQLt.validatebuild.xml all -D"db.server"="$env:fqdnAndPort" -D"db.name"=tSQLt_dev -D"db.login"="-U sa -P $env:SA_PASSWORD" -D"sqlcmd.path"="$env:sqlcmdPath"


# - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - # - #




# >>>>>>>>>>>> START HERE <<<<<<<<<<<<<<

    
    # - task: Ant@1
    #   name: Run_tSQLt_validatebuild_xml
    #   inputs:
    #     buildFile: '../tSQLt/Build/tSQLt.validatebuild.xml'
    #     options: '-Ddb.version="$(SQLVersion)" -Ddb.server="$(FQDNAndPort)" -Ddb.name=tSQLt_dev -Ddb.login="-U $(tSQLt-UserForCIEnvironment-UserName) -P $(tSQLt-UserForCIEnvironment-Password)" -Dsqlcmd.path="$(SQLCMDPath)"'
    #     targets: 'all'
    #     publishJUnitResults: true
    #     testResultsFiles: '../**/?(Example)TestResults*.xml'
    #     testRunTitle: '$(SQLVersionEdition)'
    #     javaHomeOption: 'JDKVersion'
        
    # - task: PowerShell@2
    #   name: CreateTestResultArtifact
    #   inputs:
    #     targetType: 'inline'
    #     failOnStderr: true
    #     script: |
    #       "---------------------------------------------------"
    #       $BasePath = "$(Build.SourcesDirectory)\..";
    #       $BasePath;
    #       "==================================================="
    #       $ArtifactPath = ($BasePath+"\tSQLt\Build\output\TestResults\");
    #       $ArtifactPath;
    #       "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    #       New-Item -Path $ArtifactPath  -ItemType directory -Force
    #       (Get-ChildItem $BasePath -recurse);
    #       "== == == == == == == == == == == == == == == == == "
    #       (Get-ChildItem $BasePath -recurse)|Out-File  -FilePath $ArtifactPath+"dir.txt"
    #       (Get-ChildItem $BasePath -recurse -include "*TestResults*.xml").FullName; 
    #       "==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-"
    #       (Get-ChildItem $BasePath -recurse -include "*TestResults*.xml").FullName|Copy-Item -Destination $ArtifactPath -recurse -PassThru
    #       Set-Content -Path ($ArtifactPath+"CommitId.txt") -Value "$(Build.SourceVersion)"
    #       "=== === === === === === === === === === === === ==="
    #
    # - task: PublishPipelineArtifact@1
    #   name: PublishTestResultArtifact
    #   inputs:
    #     targetPath: '$(Build.SourcesDirectory)/../tSQLt/Build/output/TestResults'
    #     artifact: 'TestResults_$(SQLVersionEdition)'
    #     publishLocation: 'pipeline'
